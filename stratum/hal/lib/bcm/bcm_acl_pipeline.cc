// Copyright 2018 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.


#include "stratum/hal/lib/bcm/bcm_acl_pipeline.h"

#include <algorithm>

#include "stratum/glue/status/canonical_errors.h"
#include "absl/memory/memory.h"
#include "absl/strings/substitute.h"
#include "util/gtl/map_util.h"

namespace stratum {
namespace hal {
namespace bcm {

::util::StatusOr<std::unique_ptr<BcmAclPipeline>>
BcmAclPipeline::CreateBcmAclPipeline(const P4ControlBlock& control_block) {
  std::unique_ptr<BcmAclPipeline> pipeline =
      absl::WrapUnique(new BcmAclPipeline());
  P4BranchCondition empty_branch;
  ::util::Status result =
      pipeline->ProcessControlBlock(control_block, empty_branch);
  if (!result.ok()) {
    pipeline.reset();
  }
  RETURN_IF_ERROR(result);
  pipeline->AssignPriorities();

  return std::move(pipeline);
}

::util::Status BcmAclPipeline::ProcessControlBlock(
    const P4ControlBlock& block, const P4BranchCondition& condition) {
  for (const P4ControlStatement& statement : block.statements()) {
    switch (statement.statement_case()) {
      case P4ControlStatement::kApply:
        if (condition.has_hit()) {
          RETURN_IF_ERROR_WITH_APPEND(
              ApplyTableOnMiss(statement.apply(), condition.hit()))
              << "Failed to process statement " << statement.ShortDebugString();
        } else {
          RETURN_IF_ERROR_WITH_APPEND(
              ApplyTable(statement.apply(), logical_pipeline_.size()))
              << "Failed to process statement " << statement.ShortDebugString();
        }
        break;
      case P4ControlStatement::kBranch:
        RETURN_IF_ERROR(ProcessBranch(statement.branch()));
        break;
      case P4ControlStatement::kDrop:
      case P4ControlStatement::kReturn:
      case P4ControlStatement::kExit:
      case P4ControlStatement::kFixedPipeline:
        // TODO: Handle these if meaningful to ACL pipeline.
        break;
      case P4ControlStatement::kOther:
        LOG(WARNING) << "Ignoring unknown control statement "
                     << statement.other();
        break;
      case P4ControlStatement::STATEMENT_NOT_SET:
        // Empty case; don't do anything.
        break;
    }
  }
  return ::util::OkStatus();
}

::util::Status BcmAclPipeline::ApplyTable(const P4ControlTableRef& table,
                                          int pipeline_stage) {
  // Sanity-check the pipeline stage. This returns an INTERNAL error code since
  // the pipeline_stage is generated by the class. If this error occurs, there
  // is a bug in the class.
  int pipeline_size = logical_pipeline_.size();
  if (pipeline_stage > pipeline_size || pipeline_stage < 0) {
    return MAKE_ERROR(util::error::INTERNAL)
           << "Cannot apply table: " << table.ShortDebugString()
           << ": Invalid pipeline stage " << pipeline_stage
           << ". Current pipeline size: " << pipeline_size
           << ". There is a bug in BcmAclPipeline.";
  }

  // Insert the table into the logical pipeline.
  BcmAclPipelineTable acl_table;
  acl_table.table = table;
  if (pipeline_stage == pipeline_size) {
    logical_pipeline_.push_back({acl_table});
  } else {
    logical_pipeline_[pipeline_stage].push_back(acl_table);
  }

  // Insert the table into the pipeline_stages_ map.
  if (!gtl::InsertIfNotPresent(&pipeline_stages_, table, pipeline_stage)) {
    return MAKE_ERROR(util::error::INVALID_ARGUMENT)
           << "Cannot apply table: " << table.ShortDebugString()
           << ". Table has already been applied.";
  }
  return ::util::OkStatus();
}

::util::Status BcmAclPipeline::ApplyTableOnMiss(
    const P4ControlTableRef& apply_table, const P4ControlTableRef& on_miss) {
  // Sanity-check the inputs.
  int pipeline_stage = gtl::FindWithDefault(pipeline_stages_, on_miss, -1);
  if (pipeline_stage < 0) {
    return ::util::NotFoundError("Unknown on-hit table reference: " +
                                 on_miss.ShortDebugString());
  }
  if (logical_pipeline_[pipeline_stage].back().table.table_id() !=
      on_miss.table_id()) {
    return MAKE_ERROR(util::error::INVALID_ARGUMENT)
           << "Cannot apply table: " << apply_table.ShortDebugString()
           << " on hit for table " << on_miss.ShortDebugString()
           << ": Another dependency already exists.";
  }

  return ApplyTable(apply_table, pipeline_stage);
}

::util::Status BcmAclPipeline::ProcessBranch(const P4IfStatement& branch) {
  switch (branch.condition().condition_case()) {
    case P4BranchCondition::kHit:
      return ProcessHitBranch(branch);
    case P4BranchCondition::kIsValid:
      // TODO: There will be valid statements here that should not
      // result in an error. We need handlers for these once we get a better
      // idea of what to expect & implement.
      return MAKE_ERROR(util::error::INVALID_ARGUMENT)
             << "Cannot process P4IfStatement: " << branch.ShortDebugString()
             << ". Condition 'is_valid' is not supported in ACL control "
                "blocks.";
    case P4BranchCondition::kUnknown:
      LOG(WARNING) << "Ignoring unknown branch condition: "
                   << branch.condition().unknown();
      break;
    case P4BranchCondition::CONDITION_NOT_SET:
      // Empty case, don't do anything.
      break;
  }
  return ::util::OkStatus();
}

::util::Status BcmAclPipeline::ProcessHitBranch(const P4IfStatement& branch) {
  if (pipeline_stages_.count(branch.condition().hit()) == 0) {
    return MAKE_ERROR(util::error::NOT_FOUND)
           << "Cannot process P4IfStatement: " << branch.ShortDebugString()
           << ". Unknown hit reference.";
  }

  const P4ControlBlock& on_hit = branch.condition().not_operator()
                                     ? branch.false_block()
                                     : branch.true_block();
  if (!on_hit.statements().empty()) {
    return MAKE_ERROR(util::error::INVALID_ARGUMENT)
           << "Cannot process P4IfStatement: " << branch.ShortDebugString()
           << ". On-hit actions are not supported in ACL control blocks.";
  }

  const P4ControlBlock& on_miss = branch.condition().not_operator()
                                      ? branch.true_block()
                                      : branch.false_block();
  return ProcessControlBlock(on_miss, branch.condition());
}

// Apply priority to tables according to the following rules:
// 1. Tables in a later logical pipeline stage have higher priority.
// 2. Tables that come earlier in the physical table have higher priority.
void BcmAclPipeline::AssignPriorities() {
  int priority = 1;
  for (PhysicalTableAsVector& stage : logical_pipeline_) {
    for (auto i = stage.rbegin(); i != stage.rend(); ++i) {
      i->priority = priority++;
    }
  }
}

std::string BcmAclPipeline::LogicalPipelineAsString() {
  if (logical_pipeline_.empty()) return "";

  // Generate template strings for each stage. Template types:
  // For strings (table names): "        "
  // For integers (priorities): "(      )"
  //              For dividers: "      | "
  std::vector<std::string> stage_str_templates;
  std::vector<std::string> stage_int_templates;
  std::vector<std::string> stage_div_templates;
  for (const PhysicalTableAsVector& stage : logical_pipeline_) {
    // Find max stage (column) width.
    size_t length = 0;
    for (const BcmAclPipelineTable& table : stage) {
      length = std::max(length, table.table.table_name().size());
      length = std::max(length, absl::StrCat("(", table.priority, ")").size());
    }
    // Create the stage template strings.
    std::string padding;
    padding.insert(0, length - 2, ' ');
    stage_str_templates.push_back(absl::StrCat(padding, "  "));
    stage_int_templates.push_back(absl::StrCat("(", padding, ")"));
    stage_div_templates.push_back(absl::StrCat(padding, "| "));
  }

  std::vector<std::string> output_lines;
  // Tables are added by physical table depth. Each depth contains 2-3 lines:
  //   Divider row (not used at depth 0).
  //   Table name row.
  //   Table ID row.
  // Tables that do not have entries are left blank.
  // Example output:
  // table1 --> table2 --> table4 --> table7 | Name Row     (Depth 0)
  // (   2)     (   4)     (   7)     (   8) | Priority Row (Depth 0)
  //     |          |          |             | Divider Row  (Depth 1)
  // table8     table3     table5            | Name Row     (Depth 1)
  // (   1)     (   3)     (   6)            | Priority Row (Depth 1)
  //                           |             | Divider Row  (Depth 2)
  //                       table6            | Name Row     (Depth 2)
  //                       (   5)            | Priority Row (Depth 2)
  size_t depth = 0;
  bool tables_found;
  do {
    std::vector<std::string> table_divs;
    std::vector<std::string> names;
    std::vector<std::string> priorities;
    tables_found = false;

    for (size_t stage = 0; stage < logical_pipeline_.size(); ++stage) {
      const PhysicalTableAsVector& stage_tables = logical_pipeline_[stage];
      if (stage_tables.size() > depth) {
        // Add dividers, names, and priorities for present tables.
        table_divs.push_back(stage_div_templates.at(stage));
        // Add the right-justified table name.
        string formatted_name = stage_str_templates.at(stage);
        const auto& table_name = stage_tables.at(depth).table.table_name();
        formatted_name.replace(formatted_name.size() - table_name.size(),
                               table_name.size(), table_name);
        names.push_back(formatted_name);
        // Add the right-justified-within-parentheses priority.
        std::string formatted_priority = stage_int_templates.at(stage);
        std::string priority = absl::StrCat(stage_tables.at(depth).priority);
        formatted_priority.replace(
            formatted_priority.size() - priority.size() - 1, priority.size(),
            priority);
        priorities.push_back(formatted_priority);
        tables_found = true;
      } else {
        // Add spacing for missing tables.
        names.push_back(stage_str_templates.at(stage));
        priorities.push_back(stage_str_templates.at(stage));
        table_divs.push_back(stage_str_templates.at(stage));
      }
    }
    // Skip output step if there were no tables.
    if (!tables_found) continue;

    // Add the divider, name, and id lines to the output vector.
    if (depth == 0) {
      output_lines.push_back(absl::StrJoin(names, " --> "));
    } else {
      output_lines.push_back(absl::StrJoin(table_divs, "     "));
      output_lines.push_back(absl::StrJoin(names, "     "));
    }
    output_lines.push_back(absl::StrJoin(priorities, "     "));
    ++depth;
  } while (tables_found);

  // Remove trailing spaces from everything.
  for (auto& line : output_lines) {
    size_t end = line.find_last_not_of(' ');
    if (end != std::string::npos) {
      line.erase(end + 1);
    }
  }

  return absl::StrJoin(output_lines, "\n");
}

}  // namespace bcm
}  // namespace hal
}  // namespace stratum
